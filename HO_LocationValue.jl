          ############################################################
          #
          # BEGIN
          #
          # Hub Optimisation Model / Sean Matthews
          # ======================================
          # Version: as VCS
          #
          # Location Value Model
          #
          ############################################################
          #

module Location_Value_Module

using Main.Type_Constants,
      Main.Constants

export

          # The  value of  an  aircraft  being in  a  location (at  an
          # airport) at any  particular time is modelled  with a value
          # function  for that  location, so  that the  complete value
          # function (for  a specific aircraft)  is a vector  over all
          # possible  locations.  We  have the  following queries  and
          # operations:

    Location_Value,

          #    return a  complete new location value  function object,
          #    initialised  with the  provided  data  (for details  of
          #    initialisation data, see code).

    Value,

          #    what is  the value of  being in  location L at  time T,
          #    with possibility of added noise if model so configured.

    Book_Generated_Value!,

          #    Record value generated by  the aircraft in executing an
          #    action. Values are generated both  in the course of the
          #    day, and by booking later  penalties.  At 'end of day',
          #    the reverse cumulative sum is the value profile for the
          #    run, which we use to recalibrate the value function.

    Initial_Location,

          #    return the best initial location    e
    Reset!

          #    reset to  the initial state, and  recalibrate using the
          #    currently  booked   training  data   (with  calibration
          #    magnitude 0 < k <= 1).
          #
          # NOTES
          #
          # Any  particular  location  function  is  weakly  monotonic
          # downwards  - if  the value  of an  aircraft being  at some
          # location (airport)  at time T is  V, then the value  of it
          # being there at  any time prior to T is  at least V, since,
          # worst case, we can simply keep it around until time T when
          # it will have the assigned value (first invariant).  We can
          # model the value  function as a sequence of  values at time
          # points.
          #
          ############################################################
          #   

struct Training_Datum
    location :: LocationID
    t        :: Time
    value    :: Money
end

struct Location_Value_Component
    values :: Vector{Money}

    Location_Value_Component(initial_value :: Money) =
        let
            L = length(time_range)
            new(initial_value .* [i/L for i in reverse(1:L)])
        end
end

struct Location_Value
    value_at_location :: Vector{Location_Value_Component}
    training_data     :: Vector{Training_Datum}

    scratch           :: Vector{Training_Datum}
    
    Location_Value(initial_value :: Money                ,
                   all_locations :: UnitRange{LocationID},
                   permitted_locations :: Vector{LocationID}) =
                       if first(all_locations) == 1
                           new([Location_Value_Component((location in permitted_locations ?
                                                          initial_value
                                                          : (-Inf :: Money)))
                                for location in all_locations],
                               Vector{Training_Datum}(),
                               Vector{Training_Datum}())
                       else
                           error("Location range does not start at 1")
                       end
end

function Value(location_value :: Location_Value,
               location       :: LocationID    ,
               t              :: Time          ;
               clean = false) :: Money

          # The current value of being in a place at a particular time
          # is defined  as the linear  interpolation of the  values to
          # the left and right.
          #
          # NOTE: NOISE  IS NORMAL AT THE  SCALE OF THE VALUE  - MIGHT
          # MAKE SENSE TO RESTRICT IT TO BEING ONLY UPSIDE?

    return if t > last_time_point
               0.0
           else
               J = t - first_time_point + 1
               v = location_value.value_at_location[location].values[J]
               v + (clean ? 0.0 : noise_scale) * randn() * v
           end    
end

function Book_Generated_Value!(location_value :: Location_Value,
                               locationID     :: LocationID    ,
                               t              :: Time          ,
                               value          :: Money         )
    
    push!(location_value.training_data, Training_Datum(locationID, t, value))

end

function Reset!(location_value :: Location_Value)

    if length(location_value.training_data) > 0
        Recalibrate!(location_value)
    end
    empty!(location_value.training_data)
    
end

function Recalibrate!(location_value :: Location_Value)

          # Update the set of location value function points using the
          # values reported in the training data.
          #
          # The  TrainingValue vector  collects  all value  generation
          # transactions, but not in  a particular order (for instance
          # a  penalty may  be  written much  further  along than  the
          # initial value it  is correcting). So we  first construct a
          # cummulative sum (for t descending) in scratch

    value_functions = location_value.value_at_location
    training_data   = location_value.training_data
    scratch         = location_value.scratch
    empty!(scratch)

    @assert length(training_data) > 0
    @assert (   length(unique(map(x -> x.t              , training_data)))
             == length(unique(map(x -> (x.t, x.location), training_data))))

    sort!(training_data, by=(x -> x.t), rev=true)
    t        = training_data[1].t
    location = training_data[1].location
    acc      = 0.0
    empty!(scratch)
    for e in training_data
        if e.t != t
            push!(scratch, Training_Datum(location, t, acc))
            t   = e.t
            location = e.location
        end
        acc += e.value
    end
    push!(scratch, Training_Datum(location, t, acc))


    v_new = 0.0

    for e in scratch
        
        t       = e.t
        value   = e.value
        value_f = value_functions[e.location].values

          # value is a _new_ value  in the training data for timepoint
          # t.  Correct the value_f at  this point in the direction of
          # value by the step-size  'descent_step' and then adjust the
          # rest of value_f to be consistent.
        
        J = t - first_time_point + 1
        v_old = value_f[J]
        v_new = (1.0 - descent_step) * v_old + descent_step * value

        value_f[J] = v_new
        
        if v_new > v_old
            while (J -= 1) > 0 && value_f[J] < v_new
                value_f[J] = v_new
            end
        else
            L = length(value_f)
            while (J += 1) <= L && value_f[J] > v_new
                value_f[J] = v_new
            end
        end
    end
end

function Initial_Location(location_value :: Location_Value) :: LocationID

    initial_location_value = map(x -> max(0.0, x.values[1]), location_value.value_at_location)
    initial_location_value  = initial_location_value ./ sum(initial_location_value)

    choices = cumsum(initial_location_value)

    if abs(last(choices) - 1.0) < 0.00001
        best_location = (rand() > noise_scale ? argmax(initial_location_value) : searchsortedfirst(choices, rand()))
    else
        println("Initial Location all negative!!")
        best_location = rand(eachindex(location_value.value_at_location)[map(x -> first(x.values) > -Inf, location_value.value_at_location)])
    end
    
    return best_location

end

end

          # END
          #
          ############################################################

